#!/usr/bin/env ruby

require 'retest'

$stdout.sync = true

Signal.trap(:INT) { $stdout.puts "Goodbye"; exit }

options = Retest::Options.new(ARGV)

if options.help?
  $stdout.puts options.help
  return
end

if options.version?
  $stdout.puts Retest::VERSION
  return
end

prompt     = Retest::Prompt.new
repository = Retest::Repository.new(files: Retest::VersionControl.files, prompt: prompt)
command    = Retest::Command.for_options(options)
runner     = Retest::Runners.runner_for(command.to_s)
sounds     = Retest::Sounds.for(options)

sounds.play(:start)
runner.add_observer(sounds)
prompt.add_observer(sounds)

program = Retest::Program.new(
  repository: repository,
  command: command,
  runner: runner
)

if options.params[:diff]
  program.diff(options.params[:diff])
  return
end

launching_message = "Launching Retest..."
if options.force_polling?
  launching_message = "Launching Retest with polling method..."
end

# Main action

$stdout.puts launching_message
Retest.listen(options) do |modified, added, removed|
  begin
    program.run(modified, added, removed)
  rescue => e
    $stdout.puts "Something went wrong: #{e.message}"
  end
end
$stdout.puts "Ready to refactor! You can make file changes now"
$stdout.puts "Press [Enter] to run all tests"

run_all_command = Retest::Command.for_options(Retest::Options.new(["--all"]), quiet: true)
run_all_runner  = Retest::Runners.runner_for(run_all_command.to_s)
loop do
  input = $stdin.getc
  if ["\r", "\n"].include?(input)
    puts "Enter pressed, running all tests"
    run_all_runner.run
  end
end
