#!/usr/bin/env ruby

require 'retest'

$stdout.sync = true
prompt_rd, prompt_wr = IO.pipe
runner_rd, runner_wr = IO.pipe

Signal.trap(:INT) do
  $stdout.puts "Goodbye"
  prompt_rd.close
  prompt_wr.close
  exit
end

options = Retest::Options.new(ARGV)

if options.help?
  $stdout.puts options.help
  return
end

if options.version?
  $stdout.puts Retest::VERSION
  return
end

prompt     = Retest::Prompt.new(input: prompt_rd)
repository = Retest::Repository.new(files: Retest::VersionControl.files, prompt: prompt)
command    = Retest::Command.for_options(options)
runner     = Retest::Runners.runner_for(command.to_s, command_stdin: runner_rd)
sounds     = Retest::Sounds.for(options)

# All test runner
all_test_command = Retest::Command.for_options(options.merge(%w[--all]), stdout: nil)
all_test_runner = Retest::Runners.runner_for(all_test_command.to_s)
all_test_runner.add_observer(sounds)

sounds.play(:start)
runner.add_observer(sounds)
prompt.add_observer(sounds)

program = Retest::Program.new(
  repository: repository,
  command: command,
  runner: runner
)

if options.params[:diff]
  prompt.input = $stdin
  runner.command_stdin = $stdin
  program.diff(options.params[:diff])
  return
end

launching_message = "Launching Retest..."
if options.force_polling?
  launching_message = "Launching Retest with polling method..."
end

# Main action

$stdout.puts launching_message
Retest.listen(options) do |modified, added, removed|
  begin
    program.run(modified, added, removed) do
      print_interactive_message
    end
  rescue => e
    $stdout.puts "Something went wrong: #{e.message}"
  end
end
$stdout.puts "Ready to refactor! You can make file changes now"

# not blocking

def print_interactive_message
  puts "\nType interactive command and press enter"
  print(">\s")
end

loop do
  print_interactive_message

  puts "waiting for input"
  input = $stdin.gets.to_s.chomp

  puts "input is: #{input.inspect}"

  if prompt.question_asked?
    prompt_wr.puts input
    next
  end

  if all_test_runner.running?
    $stdin.puts input
    next
  end

  if runner.running?
    runner_wr.puts input
    next
  end

  case input
  when 'p', 'pause'
    program.pause
    puts "Program is paused\n"
  when 'u', 'unpause'
    program.resume
    puts "Program has been resumed\n"
  when 'e', 'exit'
    Process.kill("INT", 0)
  when ''
    begin
      puts "Running last command\n"
      old_stdin = runner.command_stdin
      runner.command_stdin = $stdin
      runner.run(nil, repository: repository)
    ensure
      runner.command_stdin = old_stdin
    end
  when 'ra', 'run all'
    puts "Running all tests\n"
    all_test_runner.run
  when /^di?f?f?\s(.*)$/
    program.diff($1)
  when 'h', 'help'
    puts <<~HELP

      * 'h', 'help'              # Prints help
      * 'p', 'pause'             # Pauses Retest. Tests aren't run until unpaused.
      * 'u', 'unpause'           # Unpauses Retest
      * <ENTER>                  # Runs last changed triggered command
      * 'ra, 'run all'           # Runs all tests
      * 'd', 'diff' [GIT BRANCH] # Run matching specs that changed from a target branch
      * 'e', 'exit'              # Exits Retest
    HELP
  else
    puts "Unknown interactive command #{input}\n"
  end
end
