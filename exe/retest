#!/usr/bin/env ruby

require 'retest'

$stdout.sync = true
prompt_rd, prompt_wr = IO.pipe

Signal.trap(:INT) do
  $stdout.puts "Goodbye"
  prompt_rd.close
  prompt_wr.close
  exit
end

options = Retest::Options.new(ARGV)

if options.help?
  $stdout.puts options.help
  return
end

if options.version?
  $stdout.puts Retest::VERSION
  return
end

prompt     = Retest::Prompt.new(input: prompt_rd)
repository = Retest::Repository.new(files: Retest::VersionControl.files, prompt: prompt)
command    = Retest::Command.for_options(options)
runner     = Retest::Runners.runner_for(command.to_s)
sounds     = Retest::Sounds.for(options)

sounds.play(:start)
runner.add_observer(sounds)
prompt.add_observer(sounds)

program = Retest::Program.new(
  repository: repository,
  command: command,
  runner: runner
)

if options.params[:diff]
  program.diff(options.params[:diff])
  return
end

launching_message = "Launching Retest..."
if options.force_polling?
  launching_message = "Launching Retest with polling method..."
end

# Main action

$stdout.puts launching_message
Retest.listen(options) do |modified, added, removed|
  begin
    program.run(modified, added, removed) do
      print_interactive_message
    end
  rescue => e
    $stdout.puts "Something went wrong: #{e.message}"
  end
end
$stdout.puts "Ready to refactor! You can make file changes now"

# not blocking

def print_interactive_message
  puts "\nType interactive command and press enter"
  print(">\s")
end

loop do
  print_interactive_message

  input = $stdin.gets.to_s.chomp
  if prompt.question_asked?
    prompt_wr.puts input
    next
  end

  case input
  when 'p', 'pause'
    program.pause
    puts "Program is paused\n"
  when 'u', 'unpause'
    program.resume
    puts "Program has been resumed\n"
  when 'e', 'exit'
    Process.kill("INT", 0)
  when ''
    puts "Running last command\n"
    runner.run(nil, repository: repository)
  when 'ra', 'run all'
    puts "Running all tests\n"
    tmp_opts = options.dup.tap { |opts| opts.params[:all] = true }
    tmp_cmd = Retest::Command.for_options(tmp_opts)
    tmp_runner = Retest::Runners.runner_for(tmp_cmd.to_s)
    tmp_runner.add_observer(sounds)
    tmp_runner.run
    tmp_runner.delete_observers
  when /^di?f?f?\s(.*)$/
    program.diff($1)
  when 'h', 'help'
    puts <<~HELP

      * 'h', 'help'              # Prints help
      * 'p', 'pause'             # Pauses Retest. Tests aren't run until unpaused.
      * 'u', 'unpause'           # Unpauses Retest
      * <ENTER>                  # Runs last changed triggered command
      * 'ra, 'run all'           # Runs all tests
      * 'd', 'diff' [GIT BRANCH] # Run matching specs that changed from a target branch
      * 'e', 'exit'              # Exits Retest
    HELP
  else
    puts "Unknown interactive command #{input}\n"
  end
end
