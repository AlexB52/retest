#!/usr/bin/env ruby

require 'retest'

$stdout.sync = true
listen_rd, listen_wr = IO.pipe
Signal.trap(:INT) do
  $stdout.puts "Goodbye"
  listen_rd.close
  listen_wr.close
  exit
end

options = Retest::Options.new(ARGV)

if options.help?
  $stdout.puts options.help
  return
end

if options.version?
  $stdout.puts Retest::VERSION
  return
end

prompt     = Retest::Prompt.new
repository = Retest::Repository.new(files: Retest::VersionControl.files, prompt: prompt)
command    = Retest::Command.for_options(options)
runner     = Retest::Runner.new(command)
sounds     = Retest::Sounds.for(options)

# All test runner
all_test_command = Retest::Command.for_options(options.merge(%w[--all]), stdout: nil)
all_test_runner = Retest::Runner.new(all_test_command)
all_test_runner.add_observer(sounds)

sounds.play(:start)
runner.add_observer(sounds)
prompt.add_observer(sounds)

program = Retest::Program.new(
  repository: repository,
  command: command,
  runner: runner
)

if options.params[:diff]
  program.diff(options.params[:diff])
  return
end

launching_message = "Launching Retest..."
if options.force_polling?
  launching_message = "Launching Retest with polling method..."
end

# Main action

$stdout.puts launching_message
Retest.listen(options) do |modified, added, removed|
  begin
    repository.sync(added: added, removed: removed)
    runner.sync(added: added, removed: removed)

    listen_wr.puts "file changed: #{(modified + added).first}"
  rescue => e
    $stdout.puts "Something went wrong: #{e.message}"
  end
end
$stdout.puts "Ready to refactor! You can make file changes now"

def run_command(input:, program:, all_test_runner:)
  case input
  when /^file changed:\s(.*)$/
    puts "File changed: #{$1}"
    program.run($1)
  when 'p', 'pause'
    program.pause
    puts "Program is paused\n"
  when 'u', 'unpause'
    program.resume
    puts "Program has been resumed\n"
  when 'e', 'exit'
    Process.kill("INT", 0)
  when ''
    puts "Running last command\n"
    program.run(nil, force_run: true)
  when 'ra', 'run all'
    puts "Running all tests\n"
    all_test_runner.run
  when /^di?f?f?\s(.*)$/
    program.diff($1)
  when 'h', 'help'
    puts <<~HELP

      * 'h', 'help'              # Prints help
      * 'p', 'pause'             # Pauses Retest. Tests aren't run until unpaused.
      * 'u', 'unpause'           # Unpauses Retest
      * <ENTER>                  # Runs last changed triggered command
      * 'ra, 'run all'           # Runs all tests
      * 'd', 'diff' [GIT BRANCH] # Run matching specs that changed from a target branch
      * 'e', 'exit'              # Exits Retest
    HELP
  else
    puts "Unknown interactive command #{input}\n"
  end
end

connections = [$stdin, listen_rd]
loop do
  puts "\nType interactive command and press enter"
  print(">\s")

  ready = IO.select(connections)
  readable_connections = ready[0]
  readable_connections.each do |conn|
    data = conn.readpartial(4096)
    run_command(input: data.to_s.chomp, program: program, all_test_runner: all_test_runner)
  end
end
