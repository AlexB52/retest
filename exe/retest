#!/usr/bin/env ruby

require 'retest'

$stdout.sync = true
prompt_rd, prompt_wr = IO.pipe

Signal.trap(:INT) do
  $stdout.puts "Goodbye"
  prompt_rd.close
  prompt_wr.close
  exit
end

options = Retest::Options.new(ARGV)

if options.help?
  $stdout.puts options.help
  return
end

if options.version?
  $stdout.puts Retest::VERSION
  return
end

prompt     = Retest::Prompt.new(input: prompt_rd)
repository = Retest::Repository.new(files: Retest::VersionControl.files, prompt: prompt)
command    = Retest::Command.for_options(options)
runner     = Retest::Runners.runner_for(command.to_s)
sounds     = Retest::Sounds.for(options)

sounds.play(:start)
runner.add_observer(sounds)
prompt.add_observer(sounds)

program = Retest::Program.new(
  repository: repository,
  command: command,
  runner: runner
)

if options.params[:diff]
  program.diff(options.params[:diff])
  return
end

launching_message = "Launching Retest..."
if options.force_polling?
  launching_message = "Launching Retest with polling method..."
end

# Main action

$stdout.puts launching_message
Retest.listen(options) do |modified, added, removed|
  begin
    program.run(modified, added, removed)
  rescue => e
    $stdout.puts "Something went wrong: #{e.message}"
  end
end
$stdout.puts "Ready to refactor! You can make file changes now"

# not blocking

loop do
  input = $stdin.gets.chomp
  if prompt.question_asked?
    prompt_wr.puts input
    next
  end

  case input
  when /^pause/ then puts "it's been paused"
  when /^start/ then puts "it's been restarted"
  end
end
